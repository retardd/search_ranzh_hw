# Задания

1. В инвертированном индексе для каждого слова хранятся списки номеров документов, содержащих данное слово. Предложите варианты оптимизации процедуры пересечения таких списков.

Первоочередным, как для поиска, так и для наполнения инвертированного индекса будет реализация стеммера и избавление от знаков препинания. Последнее реализуется регулярным выражением, а под последнюю задачу могут подойти библиотеки pymorphy или opencorpora-tools, HTTP-запросы к морфологическому корпусу OpenCorpora или же поиск по xml-библиотеке лексем и форм, который можно скачать на том же сайте. 

По условию инвертированный список уже наполнен информацией, поэтому предположим, что слова, хранящиеся в нем, уже приведены к начальной форме. Следующая проблема под оптимизацию – предлоги, союзы и служебные части речи. Необходимо реализовать алгоритм, который бы определял «важность» каждого слова и отбрасывал те же предлоги. Вместе с этим выявляется еще одна проблема – сохранения целостности фразы в запросе. Я бы реализовал двухуровневую систему ранжирования – первым уровнем было бы подобие метрики tf-idf в простом исполнении (с предварительной проверкой на то, что в индексе нашлись слова с наличием документов):	

![image](https://github.com/retardd/search_ranzh_hw/assets/53952373/5e3dc6de-9e6b-46bc-a6e9-00504bff71c4)


Частота (1 множитель) находится через отношение встречаемости слова из запроса к общему количеству слов в документе. Дробная часть уравнения с коэффициентом 2 призвана сгладить возрастание частоты при росте встречаемости (поскольку если слово встречается в два раза больше, то это не значит, что документ в два раза релевантнее) – каждое последующее нахождение слова в документе менее влиятельно. Внутри логарифма же ищется отношение всех документов к документам, содержащим данное слово – данная частота как раз и показывает, насколько важно для запроса слово.
Вторым уровнем ранжирования я бы реализовал более сложную систему, которая бы вела поиск по отсортированному первой метрикой списку документов – на близость положения в тексте каждого слова из запроса по отношению к следующему – которое равно минимум 1 (учитывая пробел), что также помогало бы поднять в топ документы с наличием цельной фразы из запроса, а также популярность данного документа внутри релевантных запросов других пользователей и в целом по всем запросам.

2. Имеются две реализации алгоритма поиска – текущая и перспективная, отличающиеся между собой ранжированием документов. Как можно сравнить качество результатов поиска этих алгоритмов, чтобы принять решение о переходе на новую версию?

	Провести сравнение результатов среди пользователей
	Сравнить время поиска
	Сравнить работу при редких и популярных запросах
	Проверить поведение при запросах, имеющих знаки препинания, опечатки, повторы слов и т.д.

3.В течении сессии пользователи, как правило, могут решать несколько разных задач. Каким образом можно разделить потребности пользователя внутри его сессии?
Для решения данной задачи у вас есть следующие данные:
	запросы, разделенные по сессиям (текст, время задания запроса, id сессии);
	список документов для каждого запроса, а также информация о наличии/отсутствии клика на каждый из документов.

Разделить потребности пользователя внутри конкретно его сессии можно следующими путями:

Создание пар запросов на основе каждой сессии и их сортировка по популярности совпадения. Внутри же текущей сессии пользователю будет предложен запрос из той пары, другой элемент которой пользователь запрашивал только что.
	Ранжирование документов на основе популярности в целом (кол-во кликов на кол-во запросов, в которых он был предложен) и популярности для конкретно текущего запроса пользователя (при наличии таких в других сессиях)
	Так же благодаря наличию информации о времени каждого запроса к п.1 можно добавить учет близости запросов в каждой из пары.
	Ранжирование на основе следующего правила: выбор каждой последующей рекомендации (документов или следующего запроса) зависит от того, с какими документами взаимодействовал пользователь в текущем запросе и в прошлых, а варианты рекомендаций строятся на основе пользовательских сессий.
